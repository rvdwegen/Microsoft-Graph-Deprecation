name: Find Deprecated API Files
on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Branch to scan in target repository'
        default: 'main'
        required: true

jobs:
  scan-deprecated:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: owner/target-repo-name  # Replace with actual owner/repo
          ref: ${{ inputs.target_branch }}
          
      - name: Search for deprecated APIs and endpoints
        id: search
        run: |
          # Create results directory
          mkdir -p results
          
          # Perform deprecated search and save results
          echo "### Deprecated API Files Found ($(date '+%Y-%m-%d'))" > results/report.md
          echo "Branch: ${{ inputs.target_branch }}" >> results/report.md
          echo "" >> results/report.md
          echo "Files containing '(deprecated)' in title:" >> results/report.md
          echo "\`\`\`" >> results/report.md
          
          # Main search command with error handling
          if ! find api-reference/beta/api -name "*.md" -type f -exec grep -l "title:.*\(deprecated\)" {} \; > results/files.txt; then
            echo "::error::Search command failed"
            exit 1
          fi
          
          # Count files and store as output
          COUNT=$(wc -l < results/files.txt)
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          
          # Add results to report
          cat results/files.txt >> results/report.md
          echo "\`\`\`" >> results/report.md
          
          # Add summary
          echo "" >> results/report.md
          echo "Total files found: $COUNT" >> results/report.md

          # Create endpoints.json for storing HTTP endpoints
          echo "[]" > results/endpoints.json
          
          # Process each deprecated file to find HTTP endpoints
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              # Find all HTTP method patterns and their endpoints
              # Using awk to handle multiline matching and JSON creation
              awk '
              BEGIN { ORS="" }
              /^```\s*http/ {
                in_block=1
                next
              }
              /^```/ {
                if(in_block) in_block=0
                next
              }
              in_block && /^(GET|POST|PUT|PATCH|DELETE)\s+\/[a-zA-Z0-9\/\-_]+/ {
                endpoint=$2
                method=$1
                printf "{\"endpoint\":\"%s\",\"method\":\"%s\",\"page\":\"%s\"},\n", endpoint, method, FILENAME
              }
              ' "$file" >> results/temp_endpoints.txt
            fi
          done < results/files.txt

          # Create proper JSON array with deduplication using jq
          if [ -f results/temp_endpoints.txt ]; then
            # Remove trailing comma, wrap in array, and deduplicate based on endpoint
            (echo "["; cat results/temp_endpoints.txt | sed '$ s/,$//' ; echo "]") | \
            jq 'unique_by(.endpoint)' > results/endpoints.json
          fi

          # Cleanup
          rm -f results/temp_endpoints.txt

          # Add endpoint count to report
          ENDPOINT_COUNT=$(jq '. | length' results/endpoints.json)
          echo "" >> results/report.md
          echo "Unique endpoints found: $ENDPOINT_COUNT" >> results/report.md

      - name: Upload results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deprecated-api-scan
          path: results/
          retention-days: 90
